<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button id="btn">dianwo</button>
    <button id="btn2">dianwo2</button>
    <!-- 
        验证
        js是解释器阻塞资源；css是渲染阻塞资源
        关于CSS加载的阻塞情况：
        css加载不会阻塞DOM树的解析
        css加载会阻塞DOM树的渲染
        css加载会阻塞后面js语句的执行

        可以这样顺着流程想，目的都是渲染页面，只是看谁先谁后
        所以至少得有dom和css
        在没有js的条件下，解析dom，然后css可以并行的构建，最后合并渲染
        这个时候，如果有link外链css，会先去外链下载css文件，搞定后再渲染
        总之就是css负责的样式，样式的加载，一定是在最终渲染之前的，不然怎么渲染想要的样式
        打个比方就是，一个人什么都不穿本体是dom，css是衣服，link外链css是网购的衣服，渲染就是最后出门
        只有dom，裸着，当然可以出门（渲染成功）；
        有css的时候，dom+css，穿上衣服后，出门；
        有外链css的时候，等待网购的衣服到家后在穿上出门；


        在有js的条件下，因为js可以操作dom元素，还可以修改style样式
        所以理论上来说，js应该是在dom和css都搞定后才入场工作，
        css的加载，会阻塞后续的js执行



        js能阻塞dom构建
            在html中部，加入js，上下都有btn等dom元素，如果js执行，而页面上没有dom元素
            就可以证明js阻塞了dom的构建或者渲染
        css能阻塞js执行，link也可以，但是试验不出来，因为就算css出错或者不存在，整个过程是不会中止的，
        会继续后面的，不想js出错会报错，
        所以通常会把css放在头部，js放在body尾
        在渲染该 script标签之下的HTML元素之前，也就是说不等待后续载入的HTML元素，读到就加载并执行。

        解析过程中无论遇到的JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒 JavaScript解析器，
        就会进行暂停 (blocked )浏览器解析HTML，并等到 CSSOM 构建完毕，才去执行js脚本。
        因为脚本中可能会操作DOM元素，而如果在加载执行脚本的时候DOM元素并没有被解析，
        脚本就会因为DOM元素没有生成取不到响应元素，所以实际工程中，我们常常将资源放到文档底部。

        那么问题来了，写在js脚本后面的dom不会解析，但是后面的css或者外链css，会解析吗
        下面找到了答案：
        无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）
        原因：浏览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，
        无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，
        由浏览器自己协调。这种做法效率很高。
        所以，css外链写在后面的话，可以加载，但也不一定，要看网络速度，但是css写着后面就暂时不会解析
        外链js，会先下载，前面的代码不会阻塞下载过程，等运行到了该行代码的位置了，就按照之前的规则来
        
        每一次script后都会渲染之前解析完的dom，但后续的不会
        所以可以理解是页面的渲染不一定是一次就完成的，比如下方的代码
        在alert('本身')后，页面会出现btn2，但是不会出现js脚本后面的btn2，
        这个时候已经渲染完了一次，等btn1解析完等待渲染的时候，出现了alert('3')的js代码
        所以等alert3后才会显示btn1
    -->
    <!-- <link rel="stylesheet" href="inde.css">
    <script src="1.js"></script>
    <button id="2">2</button>
    <script>
        alert('本身')
        var btn = document.getElementById('1')
        function x() {
            alert(1)
        }
        btn.onclick = x
    </script>
    <script src="1.js"></script>
    <button id="1">1</button>
    <script>
        alert(3)
    </script>
    <link rel="stylesheet" href="index.css"> -->
    <script>

        // class Fun {
        //     constructor() {
        //         console.log('?');
        //         this.d = d
        //         this.e = () => {
        //             console.log('e', this);
        //         }
        //         this.c = ()=>{
        //             console.log('重置c');
        //         }
        //     }

        //     // a是静态方法，放在Fun类的自身上，只能由Fun调用
        //     static a() {
        //         console.log('a', this);
        //     }

        //     // b放在Fun的原型对象上，供实例对象调用,因为实例对象本身没有b，所以顺着原型链往上找
        //     b() {
        //         console.log('b', this);
        //     }

        //     // c放在了实例对象上,这种写法，可以弥补在构造器中没写的内容，
        //     // 比如构造器中写this.xxx = xxx，也可以在外部直接写xxx=xxx，是一样的，但是如果两者都写了，以构造器为准
        //     c = () => {
        //         console.log('c', this);
        //     }
        // }
        // function d() {
        //     console.log('d', this);
        // }

        // let f = new Fun()
        // console.log(f);
        // // console.log(Fun);
        // Fun.a()
        // // console.log(Fun.toString());
        // // Fun.b()//会报错--Fun.b is not a function
        // // Fun.c()//会报错--Fun.c is not a function

        // // f.a()//会报错--f.a is not a function
        // f.b()
        // f.c()
        // f.d()
        // f.e()

        // console.log('obj',Object.prototype.toString.call(f));
        // console.log('obj1',f.toString());

        // console.log('num',Object.prototype.toString.call(1));
        // console.log('str',Object.prototype.toString.call('w'));
        // 人的构造函数
        // function Person(name, age) {
        //     // 属性
        //     this.name = name;
        //     this.age = age;
        //     // 在构造函数中的方法
        //     this.eat = function () {
        //         console.log("吃吃吃");
        //     };
        // }
        // // 添加共享的属性
        // Person.prototype.sex = "男";
        // // 添加共享的方法
        // Person.prototype.sayHi = function () {
        //     console.log("哈哈哈");
        // };
        // // 实例化对象,并初始化
        // var per = new Person("张三", 18);
        // per.sayHi();
        // per.__proto__.sex='女'
        // per.sex = 'xsx'
        // per.__proto__.sayHi=function(){
        //     console.log('我改变了');
        // }



        // function Person(age) {
        //   this.age=10;
        // }
        // //人的原型对象方法
        // Person.prototype.eat=function () {
        //   console.log("吃吃吃!!!");
        // };
        // //学生的构造函数
        // function Student() {

        // }
        // let p1 = new Person(1)
        // let p3 = new Person(18);
        // Student.prototype=p3

        // Student.prototype.sayHi=function () {
        //     console.log("学学学，为中华崛起而读书!!!");
        // };

        // var stu1=new Student();
        // let p2 = new Person(2)

        // //学生的原型,指向了一个人的实例对象
        // Student.prototype=new Person(18);
        // var stu2=new Student();
        // console.dir(stu1);
        // console.dir(stu2);
        // stu.eat(); // 吃吃吃!!!
        // stu.sayHi();

        // function F1(){
        //     this.fun1 = 'fun1'
        //     console.log(this);
        //     console.log('我是F1');
        // }

        // F1.prototype.protofun1 = 'protofun1'

        // var F2 = function(){
        //     console.log('我是F2');
        // }

        // var F3 = new Function("console.log('我是F3')")

        // F1()
        // // F2()
        // // F3()
        // var f1 = new F1()
        // // f1.__proto__.protofun1 = 'protofun1+++' 
        // // F1.prototype.protofun1 = 'protofun1+++' 
        // // f1.protofun1 = 'protofun1+++'
        // console.log(f1.protofun1);

        // console.log('s');

        // function Person() {
        //     this.p1 = 'p1'
        //     this.p3 = 'p3'
        // }
        // Person.prototype.p2 = 'p2'
        // Person.prototype.p3 = 'p3_plus'


        // var p = new Person()


        // console.log(p.p1);
        // console.log(p.p2);
        // console.log(p.p3);
        // class Parent {
        //     constructor(value) {
        //         this.val = value
        //     }
        //     getValue() {
        //         console.log(this.val)
        //     }
        //     static value = 'p'
        // }
        // class Child extends Parent {
        //     constructor(value) {
        //         super(value)
        //         this.val = value
        //     }
        // }
        // let child = new Child(1)
        // child.getValue() // 1
        // child instanceof Parent // true
        // class Person { }
        // Person instanceof Function;
        // let par = new Parent()
        // let Fun = function (a) {
        //     this.x = a
        //     x = 1;
        // }
        // Fun.a = 1

        // let farray = (a) => {
        //     this.x = 1
        //     console.log('我是箭头函数');
        // }
        // farray.c = 2
        // console.log(farray.x);
        // console.log(farray.c);
        // console.log('s');
        // function fun() {
        //     console.log('1');
        // }
        // fun()
        // 'fun()'
        let now = +new Date()
        let now2 = new Date()
        console.log(now);
        console.log(now2);
        const throttle = (func, wait = 50) => {
            // 上一次执行该函数的时间
            let lastTime = 0

            return function (...args) {
                console.log(args);
                // 当前时间
                let now = +new Date()
                // 将当前时间和上一次执行函数时间对比
                // 如果差值大于设置的等待时间就执行函数
                if (now - lastTime > wait) {
                    lastTime = now
                    func.apply(this, args)
                }
            }
        }

        // setInterval(
        //     throttle(() => {
        //         console.log(1)
        //     }, 5000),
        //     1000
        // )
        const debounce = (func, wait = 50) => {
            // 缓存一个定时器id
            let timer = 0
            // 这里返回的函数是每次用户实际调用的防抖函数
            // 如果已经设定过定时器了就清空上一次的定时器
            // 开始一个新的定时器，延迟执行用户传入的方法
            return function (...args) {
                console.log('args', args);
                console.log(arguments);
                if (timer) clearTimeout(timer)
                timer = setTimeout(() => {
                    func.apply(this, args)
                }, wait)
            }
        }
        let btn = document.getElementById('btn')
        btn.onclick = debounce(() => {
            console.log('点了');
        }, 1000)
        let x = debounce((a) => {
            console.log(a);
        })
        x('??')
        console.log([1, 2] + [2, 1]);
        // const test = (func) => {
        //     return function (...param) {
        //         console.log(param);
        //         func.apply(this, param)
        //     }
        // }
        // let btn2 = document.getElementById('btn2')
        // btn2.onclick = test(() => {
        //     console.log('点了');
        // })



        // function debounceTest(arg) {
        //     console.log(arg)
        // }
        // const debounce = function (delay, fun) {
        //     let time = null
        //     return function (...args) {
        //         console.log(arguments);
        //         console.log(args);
        //         console.log(args == arguments[0]);
        //         let self = this
        //         if (time) clearTimeout(time)
        //         time = setTimeout(() => {
        //             fun.apply(self, arguments)
        //         }, delay)
        //     }
        // }
        // // 得到返回的方法
        // let fun = debounce(1000, debounceTest)

        // // 执行方法并传参
        // fun(123)
    </script>
</body>

</html>